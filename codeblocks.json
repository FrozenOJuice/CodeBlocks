[
  {
    "id": 2,
    "title": "FastAPI Backend Structure",
    "category": "Files",
    "code": "backend/\n    app/\n        __init__.py\n        main.py\n    authentication/\n        __init__.py\n        models.py\n        router.py\n        schemas.py\n        security.py\n        utils.py\n    data/\n        users.json\n        movies.json",
    "explanation": "The general file structure for a FastAPI backend",
    "lineExplanations": {}
  },
  {
    "id": 3,
    "title": "General main.py",
    "category": "FastAPI Backend",
    "code": "from fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom backend.authentication import router as authentication_router\n\napp = FastAPI()\n\napp.include_router(authentication_router.router, prefix=\"/auth\", tags=[\"auth\"])\n\napp.add_middleware(\n  CORSMiddleware,\n  allow_origins=[\"http://localhost:3000\"],  # Next.js dev server\n  allow_credentials=True,\n  allow_methods=[\"*\"],\n  allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\nasync def read_root():\n  return {\"message\": \"root route!!\"}\n\n@app.get(\"/ping\")\nasync def ping():\n  return {\"message\": \"pong\"}",
    "explanation": "This code sets up a FastAPI backend server designed to work with a Next.js frontend, featuring authentication routes mounted under the \"/auth\" prefix and basic API endpoints for root access and health checks. The application is configured with CORS middleware to securely allow cross-origin requests from the frontend development server, enabling seamless communication between the separate frontend and backend services during development. The structure provides a clean foundation for building a full-stack application with organized routing and proper cross-origin request handling.",
    "lineExplanations": {
      "1": "Imports the main FastAPI class and HTTPException for error handling",
      "2": "Imports CORS middleware to handle cross-origin requests",
      "3": "Imports authentication router from backend module",
      "4": "Blank Line",
      "5": "Creates the main FastAPI application instance",
      "6": "Blank Line",
      "7": "Includes authentication routes with \"/auth\" prefix and groups them under \"auth\" tags",
      "8": "Blank Line",
      "9": "Adds middleware to the application",
      "10": "Specifies CORS middleware type",
      "11": "Allows requests from Next.js development server running on port 3000",
      "12": "Enables cookies and authentication headers to be included in requests",
      "13": "Permits all HTTP methods (GET, POST, PUT, DELETE, etc.)",
      "14": "Allows all types of HTTP headers in requests",
      "15": "Closes the middleware configuration block",
      "16": "Blank Line",
      "17": "Decorator that defines a GET endpoint for the root path",
      "18": "Defines an asynchronous function to handle requests to the root endpoint",
      "19": "Returns a JSON response with a welcome message",
      "20": "Blank Line",
      "21": "Decorator that defines a GET endpoint for the \"/ping\" path",
      "22": "Defines an asynchronous function for the health check endpoint",
      "23": "Returns a JSON response with \"pong\" message"
    }
  },
  {
    "id": 4,
    "title": "Authentication models.py",
    "category": "FastAPI Backend",
    "code": "from pydantic import BaseModel\nfrom typing import Optional\nfrom backend.authentication.schemas import UserRole\n\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n    hashed_password: str\n    role: UserRole\n    \n    class Config:\n        from_attributes = True",
    "explanation": "This code defines a Pydantic model for representing user data in the application, specifying required fields for user identification, authentication credentials, and role-based access control. The model includes essential user attributes such as ID, username, email, securely hashed password, and role assignment, while the configuration enables compatibility with ORM objects by allowing instantiation from attribute-based data sources like database models. This structure ensures type-safe data handling and validation for user-related operations throughout the application.",
    "lineExplanations": {
      "1": "Imports BaseModel from pydantic for data validation and settings management",
      "2": "Imports Optional from typing for defining optional fields",
      "3": "Imports UserRole enum from the authentication schemas module",
      "4": "Blank Line",
      "5": "Defines a User class that inherits from Pydantic's BaseModel",
      "6": "Defines an integer field for user ID",
      "7": "Defines a string field for username",
      "8": "Defines a string field for email address",
      "9": "Defines a string field for storing the hashed password",
      "10": "Defines a role field using the imported UserRole enum type",
      "11": "Blank Line",
      "12": "Defines a nested Config class for model configuration",
      "13": "Enables ORM mode (formerly called from_attributes) to allow creating models from arbitrary class instances"
    }
  },
  {
    "id": 5,
    "title": "Utility - User Exists",
    "category": "FastAPI Backend",
    "code": "from typing import List, Dict, Any, Optional\n\ndef user_exists(users: List[Dict[str, Any]], username: str, email: str) -> tuple[bool, Optional[str]]:\n    username_taken = any(user[\"username\"] == username for user in users)\n    email_taken = any(user[\"email\"] == email for user in users)\n    \n    if username_taken and email_taken:\n        return True, \"Username and email already taken\"\n    elif username_taken:\n        return True, \"Username already taken\"\n    elif email_taken:\n        return True, \"Email already registered\"\n    \n    return False, None",
    "explanation": "This utility function provides comprehensive duplicate checking for user registration by verifying whether a given username or email already exists in a list of users. It returns detailed feedback about which specific field conflicts exist, allowing callers to provide precise error messages to users. The function efficiently handles all possible duplication scenarios - username only, email only, or both - and uses type hints for clear interface definition and better code maintainability.",
    "lineExplanations": {
      "1": "Import statement bringing in List, Dict, Any, and Optional type hints from the typing module",
      "2": "Blank line",
      "3": "Function definition that takes a list of user dictionaries, username string, and email string as parameters, returning a tuple with boolean and optional string",
      "4": "Checks if any user in the list has the specified username by iterating through all users",
      "5": "Checks if any user in the list has the specified email by iterating through all users",
      "6": "Blank line",
      "7": "Conditional check if both username and email are already taken",
      "8": "Returns a tuple with True and a message indicating both username and email are taken",
      "9": "Conditional check if only the username is already taken",
      "10": "Returns a tuple with True and a message indicating the username is taken",
      "11": "Conditional check if only the email is already registered",
      "12": "Returns a tuple with True and a message indicating the email is registered",
      "13": "Blank line",
      "14": "Returns a tuple with False and None if no duplicates are found"
    }
  },
  {
    "id": 6,
    "title": "Authentication schemas.py",
    "category": "FastAPI Backend",
    "code": "from typing import Optional, List\nfrom pydantic import BaseModel, EmailStr, validator\nfrom enum import Enum\n\nclass UserRole(str, Enum):\n    USER = \"user\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin\"\n\nclass UserBase(BaseModel):\n    username: str\n    email: EmailStr\n\nclass UserCreate(UserBase):\n    password: str\n    role: UserRole = UserRole.USER  # Default role\n    \n    @validator('password')\n    def validate_password_strength(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters')\n        return v\n\nclass UserLogin(BaseModel):\n    username: str\n    password: str\n\nclass UserResponse(UserBase):\n    role: UserRole\n    \n    class Config:\n        from_attributes = True\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n    user_id: int\n    role: UserRole \n\nclass UserUpdate(BaseModel):\n    role: Optional[UserRole] = None\n    email: Optional[EmailStr] = None",
    "explanation": "This code defines a comprehensive set of Pydantic models for user management and authentication in a FastAPI application, including role-based access control with three distinct user roles (USER, MODERATOR, ADMIN). The models handle user creation with password strength validation, user responses with ORM compatibility, login credentials, JWT token responses including role information, and user profile updates with optional fields. The schema hierarchy promotes code reuse through inheritance while ensuring data validation and type safety throughout the authentication system.",
    "lineExplanations": {
      "1": "Import statement bringing in Optional and List type hints from typing module",
      "2": "Import statement for BaseModel, EmailStr validator, and validator decorator from pydantic",
      "3": "Import statement for Enum class",
      "4": "Blank line",
      "5": "Defines a UserRole class that inherits from both string and Enum",
      "6": "Defines USER enum member with string value \"user\"",
      "7": "Defines MODERATOR enum member with string value \"moderator\"",
      "8": "Defines ADMIN enum member with string value \"admin\"",
      "9": "Blank line",
      "10": "Defines UserBase class that inherits from BaseModel",
      "11": "Defines username field as string type",
      "12": "Defines email field with EmailStr type for email validation",
      "13": "Blank line",
      "14": "Defines UserCreate class that inherits from UserBase",
      "15": "Defines password field as string type",
      "16": "Defines role field with UserRole type and sets default value to UserRole.USER",
      "17": "Blank line",
      "18": "Decorator that marks the following method as a validator for the password field",
      "19": "Defines password validation method that takes class and value parameters",
      "20": "Checks if password length is less than 8 characters",
      "21": "Raises ValueError if password is too short",
      "22": "Returns the validated password value",
      "23": "Blank line",
      "24": "Defines UserLogin class that inherits from BaseModel",
      "25": "Defines username field as string type",
      "26": "Defines password field as string type",
      "27": "Blank line",
      "28": "Defines UserResponse class that inherits from UserBase",
      "29": "Defines role field with UserRole type",
      "30": "Blank line",
      "31": "Defines nested Config class for model configuration",
      "32": "Enables ORM mode to allow creating models from arbitrary class instances",
      "33": "Blank line",
      "34": "Defines Token class that inherits from BaseModel",
      "35": "Defines access_token field as string type",
      "36": "Defines token_type field as string with default value \"bearer\"",
      "37": "Defines user_id field as type int",
      "38": "Defines role as role from UserRole enum",
      "39": "Defines role field with UserRole type for including role in token response",
      "40": "Blank line",
      "41": "Defines UserUpdate class that inherits from BaseModel",
      "42": "Defines optional role field that can be None",
      "43": "Defines optional email field that can be None"
    }
  },
  {
    "id": 7,
    "title": "Security - Hash & Verify Password",
    "category": "FastAPI Backend",
    "code": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
    "explanation": "This code provides essential password security utilities using the bcrypt hashing algorithm through the passlib library. It offers two main functions: one for securely hashing plain text passwords with salt and appropriate work factors, and another for verifying whether a given plain text password matches a previously hashed password. This implementation follows security best practices by using a proven hashing algorithm and automatically handling security considerations like salting and iteration counts.",
    "lineExplanations": {
      "1": "Import statement bringing in CryptContext from passlib library for password hashing",
      "2": "Blank line",
      "3": "Creates a CryptContext instance configured to use bcrypt hashing scheme and handle deprecated schemes automatically",
      "4": "Blank line",
      "5": "Defines a function that takes a plain text password string and returns a hashed password string",
      "6": "Returns the bcrypt hashed version of the input password using the configured context",
      "7": "Blank line",
      "8": "Defines a function that takes a plain password and hashed password and returns a boolean verification result",
      "9": "Returns True if the plain password matches the hashed password, False otherwise"
    }
  },
  {
    "id": 8,
    "title": "Security - Create Access Token",
    "category": "FastAPI Backend",
    "code": "from datetime import datetime, timezone, timedelta\nfrom typing import Optional\nimport jwt\n\nACCESS_TOKEN_EXPIRE_MINUTES = 30 \nSECRET_KEY = \"your-secret-key-here\" \nALGORITHM = \"HS256\"\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)",
    "explanation": "This code implements JWT token creation functionality with configurable expiration times, using UTC-aware timestamps for proper timezone handling and following JWT standards by including an expiration claim. The function provides flexibility by allowing custom expiration periods while defaulting to a 30-minute timeout, and securely signs tokens using HMAC-SHA256 encryption with a predefined secret key for verification purposes.",
    "lineExplanations": {
      "1": "Import statement bringing in datetime, timezone, and timedelta classes for time manipulation",
      "2": "Import statement bringing in Optional type hint for optional function parameters",
      "3": "Import statement bringing in jwt library for JSON Web Token operations",
      "4": "Blank line",
      "5": "Defines a constant for access token expiration time set to 30 minutes",
      "6": "Defines a constant for the secret key used to sign JWT tokens",
      "7": "Defines a constant for the encryption algorithm used for JWT signing",
      "8": "Blank line",
      "9": "Defines a function that takes a data dictionary and optional expiration delta, returning a JWT token string",
      "10": "Creates a copy of the input data dictionary to avoid modifying the original",
      "11": "Calculates expiration time by adding either the provided delta or default 30 minutes to current UTC time",
      "12": "Updates the data copy with the expiration timestamp using the \"exp\" claim",
      "13": "Encodes and returns the JWT token using the secret key and specified algorithm"
    }
  },
  {
    "id": 9,
    "title": "Security - Get Current User",
    "category": "FastAPI Backend",
    "code": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom backend.authentication import utils, models\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nSECRET_KEY = \"your-secret-key\"\nALGORITHM = \"HS256\"\n\ndef get_current_user(token: str = Depends(oauth2_scheme)) -> models.User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    users = utils.load_users()\n    user_dict = next((u for u in users if u[\"username\"] == username), None)\n    if not user_dict:\n        raise credentials_exception\n    return models.User(**user_dict)",
    "explanation": "This code implements JWT token authentication by creating a dependency function that validates OAuth2 bearer tokens, extracts user information from the token payload, and retrieves the corresponding user from the data store. It handles various authentication failure scenarios including invalid tokens, missing user claims, and non-existent users, providing proper HTTP responses with OAuth2-compliant headers. The function serves as a reusable dependency that can be injected into route handlers to protect endpoints requiring authenticated access.",
    "lineExplanations": {
      "1": "Import statement bringing in Depends for dependency injection, HTTPException for error handling, and status for HTTP status codes",
      "2": "Import statement for OAuth2PasswordBearer for handling OAuth2 password bearer token flow",
      "3": "Import statement for JWTError exception and jwt functions from jose library",
      "4": "Import statement for utils and models from the backend authentication module",
      "5": "Blank line",
      "6": "Creates an OAuth2PasswordBearer instance pointing to the token endpoint URL",
      "7": "Defines the secret key used for JWT token verification",
      "8": "Defines the algorithm used for JWT token verification",
      "9": "Blank line",
      "10": "Defines a dependency function that takes an OAuth2 token and returns a User model",
      "11": "Creates an HTTP exception for authentication failures with 401 status code",
      "12": "status_code=status.HTTP_401_UNAUTHORIZED",
      "13": "Sets the detailed error message for invalid credentials",
      "14": "Sets the WWW-Authenticate header as required by OAuth2 specification",
      "15": "Closes the HTTP exception block",
      "16": "Starts a try block to handle JWT decoding operations",
      "17": "Decodes the JWT token using the secret key and specified algorithm",
      "18": "Extracts the username from the \"sub\" (subject) claim in the token payload",
      "19": "Checks if the username claim is missing from the token",
      "20": "Raises credentials exception if username is not found in token",
      "21": "Starts except block to catch JWT decoding errors",
      "22": "Raises credentials exception if any JWT error occurs during decoding",
      "23": "Loads all users from the data storage using utility function",
      "24": "Searches for a user with the matching username from the token",
      "25": "Checks if no user was found with the given username",
      "26": "Raises credentials exception if user doesn't exist in the system",
      "27": "Returns a User model instance created from the user dictionary data"
    }
  },
  {
    "id": 10,
    "title": "Security - Require Role",
    "category": "FastAPI Backend",
    "code": "from fastapi import Depends, HTTPException, status\nfrom backend.authentication import models\nfrom backend.authentication.schemas import UserRole\n\ndef require_role(required_role: UserRole):\n    def role_checker(current_user: models.User = Depends(get_current_user)):\n        role_hierarchy = {\n            UserRole.USER: [UserRole.USER],\n            UserRole.MODERATOR: [UserRole.USER, UserRole.MODERATOR],\n            UserRole.ADMIN: [UserRole.USER, UserRole.MODERATOR, UserRole.ADMIN]\n        }\n        if current_user.role not in role_hierarchy[required_role]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Requires {required_role} role or higher\"\n            )\n        return current_user\n    return role_checker",
    "explanation": "This code implements a role-based access control system using a hierarchical permission structure where higher-level roles inherit permissions from lower-level roles. The function creates a reusable dependency that can be applied to route handlers to enforce role-based authorization, ensuring users have the required role or higher to access protected endpoints. The role hierarchy follows a logical progression where administrators have moderator and user privileges, moderators have user privileges, and users only have access to user-level resources.",
    "lineExplanations": {
      "1": "Import statement bringing in Depends for dependency injection, HTTPException for error handling, and status for HTTP status codes",
      "2": "Import statement for models from the backend authentication module",
      "3": "Import statement for UserRole enum from authentication schemas",
      "4": "Blank line",
      "5": "Defines a function that takes a required_role parameter and returns a dependency function",
      "6": "Defines an inner function that depends on the current user from authentication",
      "7": "Creates a dictionary defining the role hierarchy with accessible roles for each level",
      "8": "Specifies that USER role only has access to USER-level permissions",
      "9": "Specifies that MODERATOR role has access to both USER and MODERATOR level permissions",
      "10": "Specifies that ADMIN role has access to all roles (USER, MODERATOR, and ADMIN)",
      "11": "Closes the dictionary defining the role hierarchy",
      "12": "Checks if the current user's role is not in the allowed roles for the required role",
      "13": "Opens an HTTPException block",
      "14": "Raises an HTTP exception with 403 status if user doesn't have sufficient permissions",
      "15": "Provides detailed error message indicating the required role level",
      "16": "Closes the HTTPException block",
      "17": "Returns the current user if role check passes successfully",
      "18": "Returns the inner role_checker function from the outer function"
    }
  },
  {
    "id": 11,
    "title": "Utility - Save & Load Users",
    "category": "FastAPI Backend",
    "code": "import os\nimport json\nfrom typing import List, Dict, Any\nfrom backend.authentication.schemas import UserRole\n\nUSERS_FILE = os.path.join(os.path.dirname(__file__), \"..\", \"data\", \"users.json\")\n\ndef load_users() -> List[Dict[str, Any]]:\n    if not os.path.exists(USERS_FILE):\n        return []\n    with open(USERS_FILE, \"r\") as f:\n        try:\n            users = json.load(f)\n            for user in users:\n                if \"role\" not in user:\n                    user[\"role\"] = UserRole.USER.value\n            return users\n        except json.JSONDecodeError:\n            return []\n\ndef save_users(users: List[Dict[str, Any]]) -> None:\n    os.makedirs(os.path.dirname(USERS_FILE), exist_ok=True)\n    with open(USERS_FILE, \"w\") as f:\n        json.dump(users, f, indent=4)",
    "explanation": "This code provides file-based persistence utilities for user data management, handling both reading from and writing to a JSON file with proper error handling and default value assignment. The load function ensures backward compatibility by assigning default USER roles to any existing user records that lack role information, while the save function automatically creates necessary directories and formats the JSON output for readability. Both functions include robust error handling to prevent crashes from missing files or corrupt data.",
    "lineExplanations": {
      "1": "Import statement bringing in the os module for operating system interfaces",
      "2": "Import statement bringing in the json module for JSON data handling",
      "3": "Import statement bringing in List, Dict, and Any type hints from typing module",
      "4": "Import statement for UserRole enum from authentication schemas",
      "5": "Blank line",
      "6": "Defines the file path for users.json by joining directory paths",
      "7": "Blank line",
      "8": "Defines a function that returns a list of user dictionaries",
      "9": "Checks if the users file does not exist on the filesystem",
      "10": "Returns an empty list if the file doesn't exist",
      "11": "Opens the users file in read mode",
      "12": "Starts a try block to handle JSON decoding",
      "13": "Attempts to load and parse JSON data from the file",
      "14": "Begins iterating through each user in the loaded data",
      "15": "Checks if the current user dictionary lacks a \"role\" key",
      "16": "Assigns a default USER role value if role is missing",
      "17": "Returns the processed list of users",
      "18": "Catches JSON decoding errors specifically",
      "19": "Returns an empty list if JSON parsing fails",
      "20": "Blank line",
      "21": "Defines a function that takes a list of user dictionaries and returns nothing",
      "22": "Creates the directory structure for the users file if it doesn't exist",
      "23": "Opens the users file in write mode",
      "24": "Writes the users data to the file with JSON formatting and 4-space indentation"
    }
  },
  {
    "id": 12,
    "title": "Router - /register",
    "category": "FastAPI Backend",
    "code": "from fastapi import APIRouter, HTTPException\nfrom backend.authentication import schemas, utils, security\n\nrouter = APIRouter()\n\n@router.post(\"/register\", response_model=schemas.UserResponse)\ndef register(user: schemas.UserCreate):\n    users = utils.load_users()\n\n    exists, message = utils.user_exists(users, user.username, user.email)\n    if exists:\n        raise HTTPException(status_code=400, detail=message)\n\n    new_user = {\n        \"id\": len(users) + 1,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"hashed_password\": security.hash_password(user.password),\n        \"role\": user.role.value  # Store enum value\n    }\n\n    users.append(new_user)\n    utils.save_users(users)\n\n    return {\n        \"username\": new_user[\"username\"],\n        \"email\": new_user[\"email\"],\n        \"role\": new_user[\"role\"]\n    }",
    "explanation": "This code implements a user registration endpoint that validates new user credentials by checking for existing usernames and emails using a dedicated utility function, then creates a new user account with secure password hashing and proper role assignment. The endpoint handles duplicate detection through a clean abstraction that provides specific error messages, generates incremental user IDs, and persists the new user data to storage while returning a sanitized response that excludes sensitive information like passwords and internal user IDs.",
    "lineExplanations": {
      "1": "Import statement bringing in APIRouter for routing and HTTPException for error handling",
      "2": "Import statement for schemas, utils, and security modules from the authentication package",
      "3": "Blank line",
      "4": "Creates an APIRouter instance for organizing routes",
      "5": "Blank line",
      "6": "Decorator that defines a POST endpoint at \"/register\" path with UserResponse as the response model",
      "7": "Defines the register function that takes a UserCreate schema as input",
      "8": "Calls utility function to load existing users from storage",
      "9": "Blank line",
      "10": "Calls user_exists utility function to check for duplicate username and email",
      "11": "Checks if the user already exists based on the returned tuple",
      "12": "Raises an HTTP exception with 400 status if user exists, using the detailed message",
      "13": "Blank line",
      "14": "Creates a dictionary for the new user data",
      "15": "Assigns a new ID by incrementing the current user count",
      "16": "Sets the username from the input data",
      "17": "Sets the email from the input data",
      "18": "Hashes the plain text password using security function",
      "19": "Stores the enum value of the user's role",
      "20": "Closes the new user dictionary",
      "21": "Blank line",
      "22": "Adds the new user dictionary to the users list",
      "23": "Saves the updated users list back to storage",
      "24": "Blank line",
      "25": "Starts constructing the response dictionary",
      "26": "Includes the username in the response",
      "27": "Includes the email in the response",
      "28": "Includes the role in the response",
      "29": "Finishes constructing the response dictionary"
    }
  },
  {
    "id": 13,
    "title": "Router - /login",
    "category": "FastAPI Backend",
    "code": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom backend.authentication import schemas, utils, security\n\nrouter = APIRouter()\n\n@router.post(\"/login\", response_model=schemas.Token)\ndef login(form_data: OAuth2PasswordRequestForm = Depends()):\n    users = utils.load_users()\n    user = next((u for u in users if u[\"username\"] == form_data.username), None)\n\n    if not user or not security.verify_password(form_data.password, user[\"hashed_password\"]):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    access_token = security.create_access_token(\n        data={\"sub\": user[\"username\"], \"user_id\": user[\"id\"], \"role\": user[\"role\"]}\n    )\n    return {\n        \"access_token\": access_token, \n        \"token_type\": \"bearer\",\n        \"user_id\": user[\"id\"], \n        \"role\": user[\"role\"] \n    }",
    "explanation": "This code implements an OAuth2-compliant login endpoint that authenticates users by verifying their credentials against stored user data and returns a JWT bearer token upon successful authentication. The endpoint follows OAuth2 password flow standards by using the OAuth2PasswordRequestForm dependency, performs secure password verification using hashed passwords, and generates tokens containing user identity claims including username, user ID, and role for authorization purposes. Proper HTTP headers and status codes are used to maintain OAuth2 compliance throughout the authentication process.",
    "lineExplanations": {
      "1": "Import statement bringing in APIRouter for routing, Depends for dependency injection, HTTPException for error handling, and status for HTTP status codes",
      "2": "Import statement for OAuth2PasswordRequestForm for handling OAuth2 password flow form data",
      "3": "Import statement for schemas, utils, and security modules from the authentication package",
      "4": "Blank line",
      "5": "Creates an APIRouter instance for organizing routes",
      "6": "Blank line",
      "7": "Decorator that defines a POST endpoint at \"/login\" path with Token as the response model",
      "8": "Defines the login function that depends on OAuth2 password form data",
      "9": "Calls utility function to load existing users from storage",
      "10": "Searches for a user with the matching username from the form data",
      "11": "Blank line",
      "12": "Checks if user doesn't exist or password verification fails",
      "13": "Opens an HTTPException block",
      "14": "Raises an HTTP exception with 401 status for authentication failure",
      "15": "Sets the detailed error message for invalid credentials",
      "16": "Sets the WWW-Authenticate header as required by OAuth2 specification",
      "17": "Closes the HTTPException block",
      "18": "Blank line",
      "19": "Creates an access token using security function",
      "20": "Includes username as subject, user ID, and role in the token payload",
      "21": "Closes the access token",
      "22": "Starts constructing the response dictionary",
      "23": "Includes the generated access token in the response",
      "24": "Specifies the token type as \"bearer\" following OAuth2 standards",
      "25": "Includes the users id in the response",
      "26": "Includes the users role in the response",
      "27": "Ends constructing the response dictionary"
    }
  }
]